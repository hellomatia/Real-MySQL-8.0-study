# 인덱스

## 목차

- [디스크 읽기 방식](#디스크-읽기-방식)
- [인덱스란?](#인덱스란?)
- [B-Tree 인덱스](#B-Tree-인덱스)
- [B-Tree 인덱스를 통한 데이터 읽기](#B-Tree-인덱스를-통한-데이터-읽기)
- [다중 칼럼 인덱스](#다중-칼럼-인덱스)
- [B-Tree 인덱스의 정렬 및 스캔 방향](#B-Tree-인덱스의-정렬-및-스캔-방향)
- [B-Tree 인덱스의 가용성과 효율성](#B-Tree-인덱스의-가용성과-효율성)
- [R-Tree 인덱스](#R-Tree-인덱스)
- [전문 검색 인덱스](#전문-검색-인덱스)



## Reference

- [Real MySQL 8.0 - 백은빈,이성욱 (지은이) ](https://product.kyobobook.co.kr/detail/S000060313997)

인덱스는 데이터베이스 쿼리의 성능을 언급하면 빼놓을 수 없다.

각 인덱스의 특성과 차이는 상당히 중요하며, 물리 수준의 모델링을 할 때도 중요한 요소가 된다.

## 디스크 읽기 방식

컴퓨터의 CPU나 메모리처럼 전기적 특성을 띤 장치의 성능은 짧은 시간 동안 매우 빠른 속도로 발전되어왔다. 하지만 디스크와 같은 기계식 장치의 성능은 상당히 제한적으로 발전했다.

### 하드 디스크 드라이브(HDD)와 솔리드 스테이트 드라이브(SSD)

메모리와 드스크의 처리 속드는 10만배 이상의 차이를 보인다. 그에 비해 플래세 메모리를 사용하는 SSD는 1000배 가량의 차이를 보인다. 가격이 비싼 편이지만 요즘 DBMS용으로 사용할 서버에는 대부분 SSD를 채택하고 있다.

### 랜덤 I/O와 순차 I/O

랜덤 I/O는 하드 디스크 드라이브의 플래터를 돌려야 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미한다.

순차 I/O는 3개의 페이지를 디스크에 기록하기 위해 1번의 시스템 콜을 요청했지만, 랜덤 I/O는 3개의 페이지를 디스크에 기록하기 위해 3번 시스템 콜을 요청했다. 결국 속도는 3배정도 차이가 나게 된다.

디스크 원판을 가지지 않은 SSD는 랜덤 I/O와 순차 I/O의 차이가 없을 것으로 예측하지만, 그렇지 않다. SSD드라이브에서도 랜덤은 여전히 순차보다 스루풋이 떨어진다.

쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 그다지 많지 않다. 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O를 줄여주는 것이 목적이다.

랜덤 I/O를 줄여준다는 것은 필요한 데이터만 읽도록 쿼리를 계선하는 것이다.

## 인덱스란?

많은 사람이 인덱스를 언급할 때 항상 책의 맨 끝에 있는 찾아보기로 설명한다. 책의 마지막에 있는 찾아보기가 인덱스에 비유된다면 책의 내용은 데이터 파일로 비유할수 있다. 책의 찾아보기와 DBMS의 인덱스의 공통점은 정렬이다. 내용이 많아지면 우리가 원하는 검색어를 찾아내는 데 시간이 걸린다. 그래서 최대한 빠르게 검색하기 위해 정렬해서 보관한다.

DBMS의 인덱스는 SortedList와 비슷하게 저장되는 칼럼의 값을 이용해 항상 정렬된 상태를 유지한다. 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬 없이 그대로 저장해 둔다.

DBMS의 인덱스도 인덱스가 많은 테이블은 INSERT나 UPDATE, DELETE문장의 처리가 느려지게 된다. 하지만 정렬된 인덱스를 자기고 있기에 SELECT문장은 매우 빠르게 처리할 수 있다.

결론은 DBMS에서 인덱스는 데이터의 저장 성능을 희생하고 데이터의 읽기 속도를 높이는 기능이다. 테이블의 인덱스를 하나 더 추가할지 말지는 데이터의 저장 성도를 어디까지 희생할 수 있는지, 읽기 속도를 어느정도 더 빠르게 만들어야 하는지에 따라 결정하게 된다.

SELECT쿼리 문장의 WHERE조건절에 사용되는 칼럼이라고 하여 전부 인덱스로 생성되면 데이터 저장 성능이 떨어지고, 인덱스의 크기가 비대해져 역효과를 불러올 수 있다.

인덱스를 역할별로 구분해 본다면 프라이머리 키와 보조 키로 구분할 수 있다.

- 프라이머리 키: 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스이다. 레코드를 식별할 수 있는 기준값이 되기에 이를 식별자로 부르고, NULL값을 허용하지 않는고 중복을 허용하지 않는다.
- 보조 키(세컨더리 인덱스): 프라이머리 키를 제외한 나머지를 모두 보조 키로 분류한다. 유니크 인덱스는 프라이머리 키와 성격이 비슷하기에 대체 키라 부르기도 한다.

데이터 저장 방식별로 구분할 경우 상당히 많은 분류가 가능하지만 대표적으로 B-Tree 인덱스와 Hash인덱스로 구분할 수 있다. 최근에는 Fractal-Tree인덱스나 로그 기반의 Merge-Tree인덱스와 같은 알고리즘을 사용하는 DBMS도 개발되고 있다.

- B-Tree: 가장 일반적으로 사용되는 인덱스 알고리즘으로, 상당히 오래전에 도입된 알고리즘이며, 성숙해진 상태이다.
- Hash 인덱스 알고리즘: 칼럼의 값을 해시값으로 계산해서 인덱싱하는 알고리즘이다. 매우 빠른 검색을 지원한다. 값의 일부만 검색하거나, 범위를 검색시 해시 인덱스를 사용할 수 없다.

데이터의 중복 허용 여부로 유니크 인덱스, 유니크 하지 않은 인덱스로 구분 가능하다. DBMS의 쿼리를 실행해야 하는 옵티마이저에게는 상당히 중요한 문제이다. 유니크 인덱스에 =으로 검색한다는 것은 1건의 레코드만 찾으면 더 찾지 않아도 된다는 것을 옵티마이저에 알려주는 효과를 낸다.

## B-Tree 인덱스

가장 일반적이고, 가장 먼저 도입된 알고리즘이지만, 가장 범용적인 목적으로 사용하는 인덱스 알고리즘이다. B+-Tree 또는 B*-Tree가 사용된다. B-Tree의 약자는 Balanced의 약자이다.

칼럼의 원래 값을 변경하지 않고, 항상 정렬된 상태로 유지한다. 전문 검색과 같은 특수한 요건이 아닌경우, 대부분 인덱스는 B-Tree를 사용한다.

### 구조 및 특성

B-Tree인덱스를 제대로 사용하려면 기본 구조를 알아야한다. 최상위에 하나의 루트 노드가 존재하고 그 하위에 자식 노드가 붙어 있는 형태이다. 가장 하위에는 리프 노드라 한다. 트리 구조에서 루트 노드도 아닌 리프 노드도 아닌 중간 노드를 브랜치 노드라 한다. 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 조솟값을 가지고 있다.

항상 INSERT된 순서대로 저장되는 것이 아니라 삭제, 변경이 일어나 빈공간이 생기면 공간을 재활용하도록 설계되어 있다.

### B-Tree 인덱스 키 추가 및 삭제

테이블의 레코드를 저장하거나 변경하는 경우 인덱스의 키 추가나 삭제 작업이 일어나게 된다. 키 추가나 삭제가 어떠헥 처리되는 지 알면, 쿼리의 성능을 쉽게 예측할 수 있다.

### 인덱스 키 추가

테이블의 스토리지 엔진에 따라 새로운 키가 즉시 인덱스에 저장될 수 있고, 그렇지 않을 수 있다. 리프 노드가 꽉 차서 더 저장 할 수 없을 경우 리프 노드가 분리되어야 한다. 이는 상위 브랜치 노드까지 처리의 범위가 넓다. 이러한 작업에 쓰기 작업에 비용이 많이 든다.

대략적으로 계산하는 방법은 인덱스에 키를 추가하는 작업 비용을 1.5정도로 예측하는 것하는 것이다. 비용의 대부분이 디스크로 부터 인덱스 페이지를 읽고 쓰기를 해야 해서 걸리는 시간이다.

MyISAM이나 MEMORY 스토리지 엔진은 INSERT문장이 실행되면 즉시 B-Tree 인덱스에 반영하고  InnoDB의 경우 조금 더 지능적으로 작업을 지연시켜 나중에 처리 할 수 있다.

하지만, 프라이머리 키나 유니크 인덱스의 경우 중복 체크가 필요하기에 즉시 B-Tree에 추가, 삭제한다.

### 인덱스 키 삭제

키값이 삭제되는 경우는 상당히 간단하다. 리프 노드를 찾아 그냥 삭제 마크만 하면 작업이 완료된다. 삭제 마킹된 인덱스 키 공간은 방치하거나 재활용 할 수 있다.

### 인덱스 키 변경

인덱스의 키 값은 저장될 리프 노드의 위치가 결정되므로 B-Tree의 키 값이 변경되는 경우에 단순히 인덱스상의 키 값만 변경하는 것이 불가능하다. 먼저 키 값을 삭제하고, 다시 새로운 키 값을 추가하는 형태로 처리된다.

### 인덱스 키 검색

INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당하면서 인덱스를 구축하는 이유는 빠른 검색을 위해서이다. B-Tree인덱스를 이용한 검색은 100%일치 또는 값의 앞부분만 일치하는 경우 사용할 수 있다. 부등호 비교도 인덱스를 활용할 수 있지만, 인덱스를 구성하는 키 값의 뒷 부분만 검색하는 용도로 인덱스를 사용할 수 없다. 인덱스의 키 값이 변형이 가해진 후 비교되는 경우 빠른 검색 기능을 사용할 수 없다.

InnoDB 스토리지 엔진에서 인덱스는 더 특별한 의미가 있다. 레코드 잠금이나 넥스트 키락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다. 따라서 인덱스 설계가 더욱 중요하다.

### B-Tree 인덱스 사용에 영향을 미치는 요소

디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 페이지는 InnoDB 스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이다.

일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조이다. 인덱스의 페이지 크기와 키 값에 따라 노드의 개수가 결정된다.

### B-Tree 깊이

인덱스의 깊이는 상당히 중요하지만 직접 제어할 방법은 없다. 키값의 크기가 커지면 하나의 인덱스 페이지가 담을 수 있는 인덱스 키 값의 개수가 적어지고, 같은 레코드 건수라도 깊이가 깊어져서 디스크 읽기가 더 많이 필요하다. 가능하면 작게 만드는 것이 필요하다.

### 선택도(기수성)

인덱스에서 선택도 또는 기수성은 강은 의미로 사용된다. 전체 인덱스 키 값은 100개인데, 그 중 유니크한 값의 수는 10개라면 기수성은 10이다. 기수성은 낮아지고 동시에 선택도 또한 떨어진다. 성능을 높이기 위해서는 유니크한 인덱스로 검색하는 게 향상에 도움을 준다.

### 읽어야 하는 레코드의 건수

인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것 보다 높은 비용이 드는 작업이다.

일반적으로 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비용이 더 많이 드는 작업이다. 즉 인덱스를 통해 읽어야 할 레코드 건수가 전체 테이블 레코드의 20%~25%를 넘어서면 인덱스를 이용하지 않고 테이블을 모두 직접 읽어서 필터링 방식으로 처리하는 게 효율적이다.

## B-Tree 인덱스를 통한 데이터 읽기

인덱스 레인지 스캔은 인덱스의 접근 방법 가운데 가장 대표적인 방식으로, 나머지 방식보다 빠른 방법이다.

### 인덱스 레인지 스캔

인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정되었을 때 사용하는 방식이다. 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라 표현한다. 리프 노드부터 시작해 시작해야 할 위치를 찾고 리프 노드의 레코드만 순서대로 읽으면 된다. 이처럼 차례대로 쭉 읽는 것을 스캔이라 표현한다.

인덱스의 리프 노드에서 검색 조건에 일치한 건들은 데이터 파일에서 레코드를 읽어오는 과정이 필요하다. 이때 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데 한 건당 랜덤 I/O가 발생하게 된다. 그래서 데이터 레코드를 읽는 작업 비용이 많이 드는 작업으로 분류한다. 20 ~ 25%를 넘으면 인덱스를 통한 읽기보다 테이블의 데이터를 직접 읽는 것이 더 효율적인 처리 방식이 된다.

### 인덱스 풀 스캔

인덱스 레인지 스캔과 마찬가지로 인덱스를 사용하지만 레인지 스캔과 달리 처음부터 끝까지 모두 읽는 방식을 레인지 풀 스캔이라 한다. 대표적으로 쿼리의 조건절에 사용된 칼럼이 인덱스의 첫 번째 칼럼이 아닌 경우 인덱스 풀 스캔 방식이 사용된다.

일반적으로 인덱스의 크기는 테이블의 크기보다 작으므로 인덱스만 읽는 것이 효율적이다.

레인지 스캔보다 빠르지 않지만 테이블 풀 스캔보다 효율적이다. 인덱스에 포함된 칼럼만으로 쿼리를 처리할 수 있는 경우 테이블의 레코드를 읽을 필요가 없기 때문이다.

### 루스 인덱스 스캔

앞에 두 스캔 방식을 상반된 의미로 타이트 인덱스 스캔으로 분류한다. 루스 인덱스 스캔은 말 그대로 느슨하게 또는 듬성듬성하게 인덱스를 읽는 것을 의미한다.

레인지 스캔과 비슷하게 작동하지만 필요하지 않은 인덱스 키 값은 무시하고 다음으로 넘어가는 형태로 처리한다.

### 인덱스 스킵 스캔

- where 조건절에 조건이 없는 인덱스의 선행 칼럼의 유니크한 값의 개수가 적어야 함
- 쿼리가 인덱스에 존재한 칼럼만으로 처리 가능해야 함

## 다중 칼럼 인덱스

실제 서비스용 데이터베이스에서는 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다. 두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라 하며, 2개 이상의 칼럼이 연결되었다고 하여 Concatenated Index라고 한다.

다중 칼럼 인덱스에서 인덱스 내에서 각 칼럼의 위치가 상당히 중요하며, 아주 신중히 결정해야한다.

## B-Tree 인덱스의 정렬 및 스캔 방향

인덱스는 설정된 규칙에 따라 항상 오름차순이거나 내림 차순으로 정렬되어 저장된다. 어떤 인덱스가 오름차순으로 생성되었다고 해서, 인덱스를 오름차순으로 읽을 수 있다는 뜻이 아니다. 그 인덱스를 거꾸로 읽어가면 내림차순 인덱스로도 사용할 수 있다. 어느 방향으로 읽을지는 쿼리에 따라 옵티마이저가 실시간으로 만들어 실행 계획에 따라 결정된다.

### 내림차순 인덱스

역순 절렬 쿼리가 정순 정렬 쿼리보다 28.9%더 시간이 걸리는 것을 확인 할 수 있다. MySQL 서버의 InnoDB스토리지 엔진에서 정순 스캔과 역순 스캔은 페이지간의 양방향 연결 고리를 통해 전진하느냐 후진 하느냐의 차이에 있지만, 내부적으로는 느릴 수 밖에 없는 이유가 있다.

ORDER BY  … DESC하는 쿼리가 소량의 레코드에 드물게 실행되는 경우, 내림차순 인덱스를 굳이 고려할 필요는 없다.

하지만 내림차순 인덱스가 많이 실행될 경우 오름차순보다는 내림차순 인덱스가 더 효율적이라 볼 수 있다.

## B-Tree 인덱스의 가용성과 효율성

쿼리의 WHERE 조건이나 GROUP BY, 또는 ORDER BY절이 어떤 경우에 인덱스를 사용할 수 있고 어떤 방식으로 사용할 수 있는지 식별할 수 있어야 한다.

### 비교 조건의 종류와 효율성

다중 칼럼 인덱스에서 각 칼럼의 순서와 그 칼럼에 사용된 조건이 동등 비교인지 아니면 크다 또는 작다 같은 범위 조건인지에 따라 각 인덱스 칼럼의 활용 형태가 달라지며, 그 효율 또한 달라진다.

작업 범위를 결정하는 조건은 많으면 많을 수록 쿼리의 처리 성능을 높이지만 체크 조건은 많다고 해서 쿼리의 처리 성능을 높이지 못한다.

### 가용성과 효율성 판단

기본적을 B-Tree인덱스의 특성상 다음 조건에서 사용할 수 없다.

- NOT-EQUAL로 비교된 경우
- LIKE ‘%??’형태로 문자열 패턴이 비교되는 경우
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 후 비교된 이후
- NOT-DETERMINISTIC속성의 스토어드 함수나 비교 조건에 사용된 경우
- 데이터 타입이 서로 다른 비교
- 문자열 데이터 타입의 콜레이션이 다른 경우

다중 칼럼으로 만들어진 인덱스는 아래의 경우 사용할 수 없다.

- 작업 범위 결정 조건으로 인덱스를 사용하지 못하는 경우
- 작업 범위 결정 조건으로 인덱스를 사용하는 경우

## R-Tree 인덱스

MySQL의 공간 인덱스는 R-Tree 인덱스 알고리즘을 이용해 2차원의 데이ㅓㅌ를 인덱싱하고 검색하는 목적의 인덱스이다. 내부적인 내부 메커니즘은 B-Tree와 흡사하다.

최근 GPS나 지도 서비스를 내장하는 스마트 폰이 대중화되면서 SNS 서비스가 GIS와 GPS에 기반을 둔 서비스로 확장하고 있다. MySQL의 공간 확장을 이용하면 간단하게 구현할 수 있다.

- 공간 데이터를 저장할 수 있는 데이터 타입
- 공간 데이터의 검색을 위한 공간 인덱스
- 공간 데이터의 연산 함수

## 전문 검색 인덱스

대표적으로 MySQL의 B-Tree 인덱스는 실제 칼럼의 값이 1MB이더라도 전체의 값을 인덱스 키로 사용하는게 아니라 잘라서 인덱스 키로 사용한다.

문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 포함된 문서를 전문 검색에는 InnoDB나 MyISAM 스토리지 엔진에서 제공하는 일반적인 용도의 B-Tree 인덱스를 사용할 수 없다.

### 인덱스 알고리즘

전문 검색에서 문서 본문의 내용에서 사용자가 검색하게 될 키워드를 분석해 내고, 빠른 검색용으로 사용할 수 있게 이러한 키워드로 인덱스를 구축한다. 어근 분석과 n-gram분석 알고리즘으로 구분할 수 있다.

### 어근 분석 알고리즘

MySQL 서버의 전문 검색 인덱스는 아래와 같은 두가지 중요한 과정을 거쳐 색인 작업이 수행된다.

- 불용어 처리
- 어근 분석

불용어 처리는 검색에서 별 가치가 없는 단어를 모두 필터링해서 제거하는 작업을 의미한다. 불용어의 개수는 많지 않기에 알고리즘을 구현한 코드에 모두 상수로 정의해서 사용하는 경우가 많고, 불용어 자체를 데이터베이스화해서 사용자가 추가하거나 삭제할 수 있게 구현하는 경우도 있다.