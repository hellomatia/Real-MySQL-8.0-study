# 아키텍처

## 목차

- [MySQL 엔진 아키텍처](#MySQL-엔진-아키텍처)
- [InnoDB 스토리지 엔진 아키텍처](#InnoDB-스토리지-엔진-아키텍처)
- [MyISAM 스토리지 엔진 아키텍처](#MyISAM-스토리지-엔진-아키텍처)
- [MySQL 로그 파일](#MySQL-로그-파일)



## Reference

- [Real MySQL 8.0 - 백은빈,이성욱 (지은이) ](https://product.kyobobook.co.kr/detail/S000060313997)

## MySQL 엔진 아키텍처
MySQL 서버는 다른 DBMS에 비해 구조가 상당히 독특하다고 한다. 이러한 구조덕에 다른 DBMS에서 누릴 수 없는 혜택이 있지만, 반대로 문제 되지 않아도 되는 것이 문제가 생길 수 있다. MySQL 서버는 크게 MySQL엔진과 스토리지 엔진으로 구분 할 수 있다.

### MySQL 엔진

클라이언트로부터 접속, 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마니저가 중심을 이룬다. 또한MySQL은 표준 SQL문법을 지원한다.

### 스토리지 엔진

SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다. 실제 데이터를 디스크에 저장, 디스크 스토리지로부터 데이터를 읽어오는 일은 스토리지 엔진이 수행한다. MySQL엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 실행 할 수 있다.

```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

위의 방식은 정의된 INNODB가 처리한다. 이 이후로 test_table은 InnoDB가 INSERT, UPDATE, 등의 작업을 처리한다. 각 스토리지 엔진은 성능 향상을 위해 키 캐시나 InnoDB버퍼 풀과 같은 기능을 내장하고 있다.

### 핸들러 API

MySQL엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는 데, 이러한 요청을 핸들러 요청이라 한다.

### MySQL 스레딩 구조

MySQL  서버는 프로세스 기반이 아니라 스레드 기반으로 작동한다. 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.

### 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하는 스레드는 다시 스레드 캐시로 복귀한다. 이미 스레드 캐시에 지정된 개수 이상의 대기 스레드가 존재시 해당 스레드는 바로 종료시킨다. 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정한다. 데이터를 MySQL의 데이터 버퍼나 캐시로 부터 캐시를 일어와서 작업을 처리하게 된다. MyISAM데이블은 디스크 쓰기 작업까지 포그라운드 스레드가 작업하지만, InnoDB는 버퍼나 캐시까지만 포그라운드 스레드가 처리, 나머지는 백그라운드 스레드가 처리한다.

### 백그라운드 스레드

InnoDB는 다음과 같이 여러 가지 작업이 백그라운드로 처리된다.

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드이다. MySQL 5.5버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 되었다. (`innodb_write_io_threads`, `innodb_read_io_threads`) InnoDB에서 읽기는 포그라운드 스레드가 수행하기에 개수를 많이 설정할 필요가 없지만, 쓰기는 아주 많은 작업을 백구라운드 스레드가 수행하기에 2 ~ 4정도 지정하고, 나머니의 경우 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정해주는 것이 좋다.

사용자의 요청을 처리하는 도중 데이터의 쓰기는 지연될 수 있지만, 읽기는 지연될 수 없다. 대부분 DBMS의 경우 쓰기 작업을 버퍼링해서 일괄처리하는 방식을 탑재하고 있고, InnoDB도 이러한 방식으로 처리하지만, MyISAM은 사용자 쓰레드가 쓰기 작업까지 함께 처리할 수 있도록 하였다. 이러한 이유로 MyISAM에서는 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

### 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 공간은 클게 클로벌 메모리 영역과 로컬 메모리 영역으로 구분된다. 글로벌은 운영체제로부터 할당되고, 운영체에의 메모리 할당 방식은 매우 복잡하기에 정확한 메모리의 양을 측정하기 쉽지 않다.

### 클로벌 메모리 영역

일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당한다. 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만, 클라이언트의 스레드 수와 무관하다. 모든 스레드에 의해 공유된다.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 로컬 메모리 영역

세션 영역이라고 도 하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다. 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다.

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 플로그인 스토리지 엔진 모델

MySQL의 독특한 구조는 플러그인 모델이라는 점이다. 플러그인 할 수 있는 것은 스토리지 엔진만 있는게 아니라, 검색어 파서, 사용자의 인증 등 모두 플러그인으로 구현된다. MySQL은 이미 기본적으로 많은 스레드 엔진을 가지고 있지만, 다양한 사용자의 요구 조건을 만족하기에는 쉽지 않다. 이러한 요건을 기로 로 사용자가 직접 스토리지 엔진을 개발하는 것도 가능하다.

### 컴포넌트

MySQL 8.0부터는 기존의 플로그인 아키텍처를 대채하기 위해 컴포넌트 아키텍러가 지원된다. MySQL서버의 플로그인은 몇 가지 단점이 있는데, 컴포넌트는 어러한 단점을 보안해 구현되었다.

- 플러그인은 오직 MySQL서버와 인터페이스할 수 있고, 플러그인끼리 통신할 수 없음
- 플러그인은 MySQL서버의 변수와 함수를 직접 호철하기 때문에 안전하지 않다.
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어렵다.

### 쿼리 실행 구조

### 쿼리 파서

쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리하고, 트리 형태의 구조로 만들어 내는 작업을 말한다. 쿼리 문장의 기본 문법 오류는 이 과정에서 발견된다.

### 전처리기

파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재와 객체의 접근 권환을 확인한다.

### 옵티마이저

사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 경정하는 역할을 담당한다. DBMS의 두뇌에 해당한다. 옵티마이저가 더 나은 선택을 유도하는거를 중점으로 공부하게 된다. 그만큼 옵티마이저의 역할은 아주 중요하고 영향 범위 또한 아주 넓다.

### 실행 엔진

옵티마이저가 두뇌면 실행 엔진과 핸들러는 손과 발에 비용할 수 있다. 회사로 비유하면, 옵티마이저는 회상의 경영진, 실행 엔진은 중간 관리자, 핸들러는 각 업무의 실무자로 비유할 수 있다.

### 핸들러(스토리지 엔진)

핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.

## InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 덕분에 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 프라이머리 키에 의한 클러스트링

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스트링 되어 저장된다. 즉 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이다.

### 외래 키 지원

외래 키에 대한 지원은 InnoDB스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY테이블에서는 사용할 수 없다. 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크 작업이 필요하여 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다.

### MVCC(Multi Version Concurrency Control)

MVCC의 가장 큰 목적은 잠금을 상용하지 않는 일관적인 읽기를 제공하는 거셍 있다. InnoDB는 언두로그를 이용해 이 기능을 구현하고 있다.

### InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인텍스 정보를 메모리에 캐시해 두는 공간이다.  일반적인 어플리케이션에서는 INSERT, UPDATE, DELETE처럼 데이터를 변경하는 쿼리느 ㄴ데이터 파일의 이곳 저곳에 위치한 레코드를 변경하기에 랜덤한 디스크 작업을 발생시킨다. 버퍼풀이 이러한 변경되는 데이터를 모하 처리하면 랜덤한 디스크 처리 작업의 횟수를 줄일 수 있다.

### 버퍼 풀의 크기 설정

일반적으로 전체 물리 메모리의 80%정도를 InnoDB의 버퍼풀로 설정하라는 게시물이 있지만, 그렇게 단순하게 설정해서는 안된다. 메모리 공간이 8GB미만이면 50%정도만 크기로 설정해주고, 전체 메모리 공간이 그 이상이며 50%에서 시작해 조금씩 올려가면서 최적점을 찾는다.

### 버퍼 풀과 리두 로그

InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다. InnoDB의 버퍼 풀은 디스크로 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께, INSERT, UPDATE 등,  명령으로 변경된 데이터를 가진 더티 페이지도 가지고 있다. 더티 페이지는 디스크와 메모리의 데이터 상태가 다르기에 언젠가 디스크로 기록되어야 한다. MySQL서버에서는 리두 로그 파일의 전체 크기를 대략 5 ~ 10GB수준으로 선택하고 필요할 때 마다 조금씩 늘려가면서 최적값을 선택하는 것이 좋다.

### 버퍼 풀 상태 백업 및 복구

InnoDB 서버의 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연결되어 있다. 쿼리 요청이 매우 빈번하게 서버를 셧다운 했다가 다시 시작하고 서비스를 시작하면 쿼리 처리 선능이 평상시보다 1/10도 안되는 경우가 대부분이다. 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비 되어있으므로 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있기떄문이다. 디스크의 데이터가 버퍼 풀에 적재되어 있는 상태를 워밍업 상태라고 표현하는데 버퍼 풀이 잘 워밍업된 상태에서 그렇지 않은 경우보다 몇십배의 쿼리 처리 속도를 보이는 게 일반적이다. MySQL 5.5버전에서 는 점검을 위해 서버를 셧다운했다가 다시 시작하는 경우에도 강제 워밍업을 위해 조요 테이블과 인덱스에 대해 풀 스캔을 한번씩 실행하고 서비스를 오픈했다.

MySQL 5.6버전 부터는 버퍼 풀 덤프 및 적재 기능이 존재 기능이 도입되었다. 서버 점검이나 기타 작업을 위해 재시작하는 경우 시스템 변수를 이용해 InnoDB버퍼 풀의 상태를 백업할 수 있다.

```sql
// MySQL 서버 셧다운 전에 버퍼 풀의 상태를 백업
SET GLOBAL innodb_buffer_pool_dump_now=ON;

// MySQL 서버 셧다운 전에 버퍼 풀의 상태를 복구
SET GLOBAL innodb_buffer_pool_load_now=ON;
```

이 작업을 수동으로 하기에는 쉽지 않다. 다른 작업을 위해 MySQL서버를 재시작하는 경우 해야 할 작업에 집중한 나머지 백업과 복구 과정을 잊어버리기 십상이다. MySQL서버가 시작되면 자동으로 백업된 버퍼 풀의 상태를 복구할 수 있는 기능을 제공한다.
## InnoDB 스토리지 엔진 아키텍처

## MyISAM 스토리지 엔진 아키텍처

## MySQL 로그 파일
