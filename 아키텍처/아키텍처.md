# 아키텍처

## 목차

- [MySQL 엔진 아키텍처](#MySQL-엔진-아키텍처)
- [InnoDB 스토리지 엔진 아키텍처](#InnoDB-스토리지-엔진-아키텍처)
- [MyISAM 스토리지 엔진 아키텍처](#MyISAM-스토리지-엔진-아키텍처)
- [MySQL 로그 파일](#MySQL-로그-파일)



## Reference

- [Real MySQL 8.0 - 백은빈,이성욱 (지은이) ](https://product.kyobobook.co.kr/detail/S000060313997)

## MySQL 엔진 아키텍처
MySQL 서버는 다른 DBMS에 비해 구조가 상당히 독특하다고 한다. 이러한 구조덕에 다른 DBMS에서 누릴 수 없는 혜택이 있지만, 반대로 문제 되지 않아도 되는 것이 문제가 생길 수 있다. MySQL 서버는 크게 MySQL엔진과 스토리지 엔진으로 구분 할 수 있다.

### MySQL 엔진

클라이언트로부터 접속, 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마니저가 중심을 이룬다. 또한MySQL은 표준 SQL문법을 지원한다.

### 스토리지 엔진

SQL 문장을 분석하거나 최적화하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다. 실제 데이터를 디스크에 저장, 디스크 스토리지로부터 데이터를 읽어오는 일은 스토리지 엔진이 수행한다. MySQL엔진은 하나지만 스토리지 엔진은 여러 개를 동시에 실행 할 수 있다.

```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```

위의 방식은 정의된 INNODB가 처리한다. 이 이후로 test_table은 InnoDB가 INSERT, UPDATE, 등의 작업을 처리한다. 각 스토리지 엔진은 성능 향상을 위해 키 캐시나 InnoDB버퍼 풀과 같은 기능을 내장하고 있다.

### 핸들러 API

MySQL엔진의 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때는 각 스토리지 엔진에 쓰기 또는 읽기를 요청하는 데, 이러한 요청을 핸들러 요청이라 한다.

### MySQL 스레딩 구조

MySQL  서버는 프로세스 기반이 아니라 스레드 기반으로 작동한다. 크게 포그라운드 스레드와 백그라운드 스레드로 구분할 수 있다.

### 포그라운드 스레드(클라이언트 스레드)

포그라운드 스레드는 최소한 MySQL 서버에 접속된 클라이언트의 수만큼 존재하며, 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다. 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하는 스레드는 다시 스레드 캐시로 복귀한다. 이미 스레드 캐시에 지정된 개수 이상의 대기 스레드가 존재시 해당 스레드는 바로 종료시킨다. 최대 스레드 개수는 `thread_cache_size` 시스템 변수로 설정한다. 데이터를 MySQL의 데이터 버퍼나 캐시로 부터 캐시를 일어와서 작업을 처리하게 된다. MyISAM데이블은 디스크 쓰기 작업까지 포그라운드 스레드가 작업하지만, InnoDB는 버퍼나 캐시까지만 포그라운드 스레드가 처리, 나머지는 백그라운드 스레드가 처리한다.

### 백그라운드 스레드

InnoDB는 다음과 같이 여러 가지 작업이 백그라운드로 처리된다.

- 인서트 버퍼를 병합하는 스레드
- 로그를 디스크로 기록하는 스레드
- InnoDB버퍼 풀의 데이터를 디스크에 기록하는 스레드
- 데이터를 버퍼로 읽어 오는 스레드
- 잠금이나 데드락을 모니터링하는 스레드

가장 중요한 것은 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드이다. MySQL 5.5버전부터 데이터 쓰기 스레드와 데이터 읽기 스레드의 개수를 2개 이상 지정할 수 있게 되었다. (`innodb_write_io_threads`, `innodb_read_io_threads`) InnoDB에서 읽기는 포그라운드 스레드가 수행하기에 개수를 많이 설정할 필요가 없지만, 쓰기는 아주 많은 작업을 백구라운드 스레드가 수행하기에 2 ~ 4정도 지정하고, 나머니의 경우 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정해주는 것이 좋다.

사용자의 요청을 처리하는 도중 데이터의 쓰기는 지연될 수 있지만, 읽기는 지연될 수 없다. 대부분 DBMS의 경우 쓰기 작업을 버퍼링해서 일괄처리하는 방식을 탑재하고 있고, InnoDB도 이러한 방식으로 처리하지만, MyISAM은 사용자 쓰레드가 쓰기 작업까지 함께 처리할 수 있도록 하였다. 이러한 이유로 MyISAM에서는 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.

### 메모리 할당 및 사용 구조

MySQL에서 사용되는 메모리 공간은 클게 클로벌 메모리 영역과 로컬 메모리 영역으로 구분된다. 글로벌은 운영체제로부터 할당되고, 운영체에의 메모리 할당 방식은 매우 복잡하기에 정확한 메모리의 양을 측정하기 쉽지 않다.

### 클로벌 메모리 영역

일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당한다. 필요에 따라 2개 이상의 메모리 공간을 할당받을 수 있지만, 클라이언트의 스레드 수와 무관하다. 모든 스레드에 의해 공유된다.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

### 로컬 메모리 영역

세션 영역이라고 도 하며, MySQL 서버상에 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다. 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다는 특징이 있다.

- 정렬 버퍼
- 조인 버퍼
- 바이너리 로그 캐시
- 네트워크 버퍼

### 플로그인 스토리지 엔진 모델

MySQL의 독특한 구조는 플러그인 모델이라는 점이다. 플러그인 할 수 있는 것은 스토리지 엔진만 있는게 아니라, 검색어 파서, 사용자의 인증 등 모두 플러그인으로 구현된다. MySQL은 이미 기본적으로 많은 스레드 엔진을 가지고 있지만, 다양한 사용자의 요구 조건을 만족하기에는 쉽지 않다. 이러한 요건을 기로 로 사용자가 직접 스토리지 엔진을 개발하는 것도 가능하다.

### 컴포넌트

MySQL 8.0부터는 기존의 플로그인 아키텍처를 대채하기 위해 컴포넌트 아키텍러가 지원된다. MySQL서버의 플로그인은 몇 가지 단점이 있는데, 컴포넌트는 어러한 단점을 보안해 구현되었다.

- 플러그인은 오직 MySQL서버와 인터페이스할 수 있고, 플러그인끼리 통신할 수 없음
- 플러그인은 MySQL서버의 변수와 함수를 직접 호철하기 때문에 안전하지 않다.
- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어렵다.

### 쿼리 실행 구조

### 쿼리 파서

쿼리 파서는 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리하고, 트리 형태의 구조로 만들어 내는 작업을 말한다. 쿼리 문장의 기본 문법 오류는 이 과정에서 발견된다.

### 전처리기

파서 과정에서 만들어진 파서 트리를 기반으로 쿼리 문장에 구조적인 문제점이 있는지 확인한다. 각 토큰을 테이블 이름이나 칼럼 이름, 또는 내장 함수와 같은 개체를 매핑해 해당 객체의 존재와 객체의 접근 권환을 확인한다.

### 옵티마이저

사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지를 경정하는 역할을 담당한다. DBMS의 두뇌에 해당한다. 옵티마이저가 더 나은 선택을 유도하는거를 중점으로 공부하게 된다. 그만큼 옵티마이저의 역할은 아주 중요하고 영향 범위 또한 아주 넓다.

### 실행 엔진

옵티마이저가 두뇌면 실행 엔진과 핸들러는 손과 발에 비용할 수 있다. 회사로 비유하면, 옵티마이저는 회상의 경영진, 실행 엔진은 중간 관리자, 핸들러는 각 업무의 실무자로 비유할 수 있다.

### 핸들러(스토리지 엔진)

핸들러는 MySQL 서버의 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어 오는 역할을 담당한다.

## InnoDB 스토리지 엔진 아키텍처

InnoDB는 MySQL에서 사용할 수 있는 스토리지 엔진 중 거의 유일하게 레코드 기반의 잠금을 제공하며, 그 덕분에 동시성 처리가 가능하고 안정적이며 성능이 뛰어나다.

### 프라이머리 키에 의한 클러스트링

InnoDB의 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스트링 되어 저장된다. 즉 프라이머리 키 값의 순서대로 디스크에 저장된다는 뜻이다.

### 외래 키 지원

외래 키에 대한 지원은 InnoDB스토리지 엔진 레벨에서 지원하는 기능으로 MyISAM이나 MEMORY테이블에서는 사용할 수 없다. 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크 작업이 필요하여 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다.

### MVCC(Multi Version Concurrency Control)

MVCC의 가장 큰 목적은 잠금을 상용하지 않는 일관적인 읽기를 제공하는 거셍 있다. InnoDB는 언두로그를 이용해 이 기능을 구현하고 있다.

### InnoDB 버퍼 풀

InnoDB 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인텍스 정보를 메모리에 캐시해 두는 공간이다.  일반적인 어플리케이션에서는 INSERT, UPDATE, DELETE처럼 데이터를 변경하는 쿼리느 ㄴ데이터 파일의 이곳 저곳에 위치한 레코드를 변경하기에 랜덤한 디스크 작업을 발생시킨다. 버퍼풀이 이러한 변경되는 데이터를 모하 처리하면 랜덤한 디스크 처리 작업의 횟수를 줄일 수 있다.

### 버퍼 풀의 크기 설정

일반적으로 전체 물리 메모리의 80%정도를 InnoDB의 버퍼풀로 설정하라는 게시물이 있지만, 그렇게 단순하게 설정해서는 안된다. 메모리 공간이 8GB미만이면 50%정도만 크기로 설정해주고, 전체 메모리 공간이 그 이상이며 50%에서 시작해 조금씩 올려가면서 최적점을 찾는다.

### 버퍼 풀과 리두 로그

InnoDB의 버퍼 풀과 리두 로그는 매우 밀접한 관계를 맺고 있다. InnoDB의 버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정하면 할수록 쿼리의 성능이 빨라진다. InnoDB의 버퍼 풀은 디스크로 읽은 상태로 전혀 변경되지 않은 클린 페이지와 함께, INSERT, UPDATE 등,  명령으로 변경된 데이터를 가진 더티 페이지도 가지고 있다. 더티 페이지는 디스크와 메모리의 데이터 상태가 다르기에 언젠가 디스크로 기록되어야 한다. MySQL서버에서는 리두 로그 파일의 전체 크기를 대략 5 ~ 10GB수준으로 선택하고 필요할 때 마다 조금씩 늘려가면서 최적값을 선택하는 것이 좋다.

### 버퍼 풀 상태 백업 및 복구

InnoDB 서버의 버퍼 풀은 쿼리의 성능에 매우 밀접하게 연결되어 있다. 쿼리 요청이 매우 빈번하게 서버를 셧다운 했다가 다시 시작하고 서비스를 시작하면 쿼리 처리 선능이 평상시보다 1/10도 안되는 경우가 대부분이다. 버퍼 풀에 쿼리들이 사용할 데이터가 이미 준비 되어있으므로 디스크에서 데이터를 읽지 않아도 쿼리가 처리될 수 있기떄문이다. 디스크의 데이터가 버퍼 풀에 적재되어 있는 상태를 워밍업 상태라고 표현하는데 버퍼 풀이 잘 워밍업된 상태에서 그렇지 않은 경우보다 몇십배의 쿼리 처리 속도를 보이는 게 일반적이다. MySQL 5.5버전에서 는 점검을 위해 서버를 셧다운했다가 다시 시작하는 경우에도 강제 워밍업을 위해 조요 테이블과 인덱스에 대해 풀 스캔을 한번씩 실행하고 서비스를 오픈했다.

MySQL 5.6버전 부터는 버퍼 풀 덤프 및 적재 기능이 존재 기능이 도입되었다. 서버 점검이나 기타 작업을 위해 재시작하는 경우 시스템 변수를 이용해 InnoDB버퍼 풀의 상태를 백업할 수 있다.

```sql
// MySQL 서버 셧다운 전에 버퍼 풀의 상태를 백업
SET GLOBAL innodb_buffer_pool_dump_now=ON;

// MySQL 서버 셧다운 전에 버퍼 풀의 상태를 복구
SET GLOBAL innodb_buffer_pool_load_now=ON;
```

이 작업을 수동으로 하기에는 쉽지 않다. 다른 작업을 위해 MySQL서버를 재시작하는 경우 해야 할 작업에 집중한 나머지 백업과 복구 과정을 잊어버리기 십상이다. MySQL서버가 시작되면 자동으로 백업된 버퍼 풀의 상태를 복구할 수 있는 기능을 제공한다.
## InnoDB 스토리지 엔진 아키텍처

### Double Write Buffer

InnoDB 스토리지 엔진의 리두 로그는 리두 로그 공간의 낭비를 막기 위해 페이지의 변경된 내용만 기록한다. 이런한 현상에 디스크 파일에 일부만 기록되는 현상이 발생할 수 있다. 페이지가 일부만 기록되는 현상을 파셜 페이지 또는 톤 페이지라고 한다.

이러한 현상을 막기 위해 Double-Write 기법을 이용하게 된다. InnoDB 스토리지 엔진은 실제 데이터 파일에 변경 내용을 기록하기 전, 더티 페이지를 우선 묶어 시스템 테이블스페이스의 DoubleWrite 버퍼에 기록한다. 그 후, InnoDB스토리지 엔진은 각 더티 페이지를 파일의 적당한 위치에 하나씩 랜덤으로 쓰기를 실행한다.

정상적으로 디스크에 작성되면, Double Write는 필요없게 된다. 하지만, 비정상적으로 종료될 경우, InnoDB는 재시작 될때 Double Wirte 버퍼의 내용과 디스크 내용과 비교하고, 다른 내용이 있으면 버퍼의 내용을 데이터 파일의 페이지로 복사하게 된다.

HDD는 부담스럽지 않지만,  SSD처럼 IO나 순차 IO의 비용이 비슷한 저장 시스템에서는 상당히 부담스럽다.

### 언두 로그

InnoDB 스토리지 엔진은 트랜잭션과 격리 수준을 보장하기 위해 DML로 변경되기 전 데이터를 별도로 백업한다. 이러한 데이터를 언두 로그라 한다.

- 트랜잭션 보장
- 격리 수준 보장

업데이터 문장이 실행되면 트랜잭션을 커밋 하지 않아도 실제 데이터 파일 내용은 변경된다. 언두 로그는 변경되기 전의 내용이 기록되게 된다. 롤백을 하면 언두 영역의 백업된 데이터를 다시 데이터 파일로 복구한다.

언두로그의 저장 공간은 한번 늘어나면, 줄어들지 않는다.

언두 로그가 저장되는 공간을 언두 테이블스페이스라고 한다. 5.6버전 이전까지는 언두 테이블스페이스에 저장되었다. 하지만 언두 로그는 서버가 초기화 될때 생성되기에 확장에 한계가 있다. 5.6버전 이후 부터는 `innodb_undo_tablespaces`시스템 변수에 2보다 큰 값을 설정하면, 별도의 파일을 통해 관리하도록 되었다. 8.0이후 부터는 언두 로그는 항상 시스템 테이블스페이스 외부의 별도 로그 파일에 기록된다.

### 체인지 버퍼

RDBMS에서 레코드가 INSERT되거나 UPDATE될 때는 데이터 파일을 변경하는 작업과 함께, 해당 레이블의 인덱스를 업데이트하는 작업도 필요하다. 인덱스 페이지가 버퍼 풀에 있으면 바로 업데이트를 수행하고, 그렇지 않으면 임시 공간에 저장하고 결과를 반환하는 형태로 성능 향상 시킨다. 이 임시 공간이 체인지 버퍼라 한다.

중복을 확인해야하는 유니크 인덱스는 체인지 버퍼를 사용할 수 없다. 체인지 버퍼에 있는 데이터는 이후 백그라운드 스레드에 의해 병합하게 된다. 이 역할을 하는 스레드를 체인지 버퍼 머지 스레드라고 한다.

### 리두 로그 및 로그 버퍼

리두 로그는 트랜잭션의 4가지 요소인  ACID중에서 D에 해당하는 영속성과 가장 밀접하게 연관되어 있다. MySQL 서버를 포함한 대부분 데이터베이스 서버는 데이터 변경 내용을 로그로 먼저 기록한다. 비정상 종료가 발생시 리두 로그의 내용을 이용해 데이터 파일을 다시 서버가 종료되기 직전의 상태로 복구한다.

- 커밋되었지만, 데이터 파일에 기록되지 않은 데이터
- 롤백되었지만, 데이터 파일에 이미 기록된 데이터

첫 번째의 경우 리두 로그에 저장된 데이터를 데이터 파일에 다시 복사하면 된다. 하지만 후자는 리두 로그로 해결할 수 없다. 이때, 언두 로그의 내용르 가져와 데이터 파일에 복사하면 된다.

### 리두 로그 아카이빙

MySQL 8.0버전 부터는 InnoDB스토리지 엔진의 리두 로그를 아카이빙 하는 기능이 추가되었다.

### 리두 로그 활성화 및 비활성화

InnoDB스토리지 엔진의 리두 로그는 하드웨어나 소프트웨어 등 여러가지 문제점으로 서버가 비정상적으로 종료되었을 때, 데이터 파일에 기록되지 못 한 트랜잭션을 복구하기 위해 항상 활성화되어있다. 트랜잭션이 커밋되어도 데이터 파일은 즉시 디스크로 동기화되지 않고, 리두 로그는 항상 디스크로 기록된다.

### 어댑티브 해시 인덱스**

일반적으로 인덱스라고 하면 이는 테이블에 사용자가 생성해둔 B-Tree 인덱스를 의미한다. 인덱스가 사용하는 알고리즘이 B-Tree는 아니더라도, 사용자가 직접 테이블에 생성해둔 인덱스가 우리가 일반적으로 알고 있는 인덱스 일것이다. 하지만 어댑티브 해시 인덱스는 사용자가 수동으로 생성하는 인덱스가 아니라, InnoDB 스토리지 엔진에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성하는 인덱스이다.

B-Tree인덱스에서 특정 값을 찾는 과정이 매우 빠르게 처리된다고 생각하지만, 속도의 기준은 상대적인 것이다. 데이터베이스 서버가 얼마나 많은 일을 하느냐에 따라 B-Tree 인덱스에서 값을 찾는 과정이 느려질 수 있고, 빨라질 수 있다. 적당한 사양의 컴퓨터에서는 성능저하가 보이지 않겠지만, 수천개의 스레드가 실행되면, 자연히 쿼리의 성능은 떨어지게 된다.

어댑티브 해시 인덱스는 자주 읽히는 데이터 페이지의 키 값을 이용해 해시 인덱스를 생성하고, 필요시 해시 인덱스를 검핵해 저장된 데이터 페이지를 즉시 찾아간다. 루트, 노드, 리프 노드 까지 찾아가는 비용이 없어진다. 어뎁티브 해시 인덱스는 하나만 존재한다.

- 성능에 크게 도움이 되지 않은 경우
    - 디스크 읽기가 많은 경우
    - 특정 패턴의 쿼리가 많은 경우
    - 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우
- 성능에 도움이 되는 경우
    - 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우
    - 동등 조건 검색이 많은 경우
    - 쿼리가 데이터 중에서 일부 데이터에만 집중되는 경우

## MyISAM 스토리지 엔진 아키텍처

### InnoDB vs MyISAM, MEMORY 스토리지 엔진 비교

기존에는 MyISAM이 기본적인 스토리지 엔진으로 채택되는 경우가 많았지만, 현재는 서버의 모든 기능을 InnoDB로만 구현할 수 있다. 이후 버전은 MyISAM 스토리지 엔진은 없어질 것으로 예상된다.

MEMORY 스토리지 엔진이 이름 덕에 과대 평가를 받는 경향도 있지만 동시 처리 성능은 InnoDB 를 따라갈 수 없다.

## MySQL 로그 파일

MySQL서버에서 서버의 상태를 진단할 수 있는 많은 도구를 지원하지만, 이러한 도구를 사용하기 위해서는 많은 지식이 필요한 경우가 많다. 하지만 로그 파일을 이용하면 MySQL 서버의 깊은 내부 지식이 없어도 상태나 부하를 일으키는 원인을 쉽게 찾아 해결 할 수 있다. 많은 사용자가 로그 파일의 내용을 무시하고 다른 방법으로 해결책을 찾으려 노력하는데, 서버에 문제가 생기면 로그파일을 자세히 확인하는 자세가 필요하다.

### 에러 로그 파일

에러나 경고 메시지가 출력되는 로그파일이다. 설정 파일(my.cnf)에서 log_error라는 이름의 파라미터로 정의된 경로에 생성된다. 별도로 지정하지 않은 경우 .err라는 확장자가 붙은 파일로 생성된다.

```sql
mysqld: read for connections // 정상적으로 기동
```

재시작 할 때, 문제가 있어 복구를 하지 못할 경우

```sql
innodb_force_recovery // 0보다 큰 값으로 설정
```

### 제너럴 쿼리 로그 파일

서버에서 실행되는 쿼리로 어떤 것들이 있는지 전체 목록을 뽑아사 검토해 볼 때가 있는데, 이때는 쿼리 로그를 활성화 시켜 쿼리 로그 파일로 기록하게 한 다음, 그 파일을 검토하게 하면 된다. 슬로우 쿼리 로그와 다르게 쿼리 요청을 받으면 바로 기록하기에 에러가 발생해도 일단 로그 파일에 기록한다.

### 슬로우 쿼리 로그

서버의 쿼리 튜닝은 크게 서비스가 적용되기 전, 전체적으로 튜닝하는 경우와 서비스 운영중 성능 저하를 검사하거나 장기적인 점검을 위한 튜닝으로 나뉜다. 전자는 쿼리가 전부라 모두 튜닝하면 되거나, 후자는 어떤 쿼리가 문제인지 판단하기 쉽지 않다. 이때 슬로우 쿼리 로그가 많은 도움이 된다.

슬로우 쿼리는 로그 파일에 `long_query_time`시스템 변수에 설정한 시간 이상 소요된 쿼리가 모두 기록된다. 슬로우 쿼리 로그 파일에 기록된 쿼리는 일단 정상적으로 실행이 완료되었고, 실행하는 데 걸린 시간이 정의된 시간보다 많이 걸린 쿼리인 것이다.

```sql
Time // 쿼리가 종료된 시점
User@Host // 쿼리를 실행한 사용자
Query_time // 쿼리가 실행되는데 걸린 전체 시간
Rows_examined // 쿼리가 처리되기 위해 몇 건의 레코드에 접근했는 지
Lock_time // InnoDB에서 별 도움되지 않은 정보
```

Percona에서 개발한 Percona ToolKit의 pt_query_digest 스크립트를 이용하면 쉽게 빈도나 처리 성능별로 쿼리를 정렬할 수 있다.

### 슬로우 쿼리 통계

분석 결과의 최상단에 표시되고, 모든 쿼리를 대상으로 실행 시간, 잠금 대기 시간 등에 대해 평균 및 최소/최대 값을 표시한다.

### 실행 빈도 및 누적 실행 시간순 랭킹

각 쿼리별로 응답 시간과 실행 횟수를 보여주는데, pt-query-digest명령 실행 시 —order-by옵션으로 정렬 순서를 변경할 수 있다.

### 쿼리별 실행 횟수 및 누적 실행 시간 상세 정보

쿼리를 쿼리 랭킹에 표시된 순서대로 자세한 내용을 보여준다. 랭킹별 쿼리에서 대상 데이블에 어떤 쿼리인지만 표시한다.